<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>agentctl: Headless Orchestration for Coding Agents | Charlie Hulcher</title><meta name=title content="agentctl: Headless Orchestration for Coding Agents | Charlie Hulcher"><meta name=description content="Engineering Leader and AI Researcher focused on building tech startup teams and exploring advanced AI applications."><meta name=author content="Charlie Hulcher"><meta property="og:type" content="article"><meta property="og:url" content="https://charlie.engineer/posts/agentctl/"><meta property="og:title" content="agentctl: Headless Orchestration for Coding Agents | Charlie Hulcher"><meta property="og:description" content="I built a CLI that wraps coding agents for headless orchestration.


The friction of going headless
I&rsquo;ve been running coding agents headlessly as my primary way of writing software. Not as a side experiment, but as the default. And the friction points became obvious fast.
You launch a Claude Code session, move on to something else, and forget what it&rsquo;s doing. You launch another session in the same directory without realizing it, and they clobber each other&rsquo;s work. You hear about a new model or a new agent tool, but the switching cost is high enough that you just stick with what works. Why bother?"><meta property="og:image" content="https://charlie.engineer/images/profile/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name=twitter:card content="summary_large_image"><meta property="twitter:domain" content="charlie.engineer"><meta property="twitter:url" content="https://charlie.engineer/posts/agentctl/"><meta name=twitter:title content="agentctl: Headless Orchestration for Coding Agents | Charlie Hulcher"><meta name=twitter:description content="I built a CLI that wraps coding agents for headless orchestration.


The friction of going headless
I&rsquo;ve been running coding agents headlessly as my primary way of writing software. Not as a side experiment, but as the default. And the friction points became obvious fast.
You launch a Claude Code session, move on to something else, and forget what it&rsquo;s doing. You launch another session in the same directory without realizing it, and they clobber each other&rsquo;s work. You hear about a new model or a new agent tool, but the switching cost is high enough that you just stick with what works. Why bother?"><meta name=twitter:image content="https://charlie.engineer/images/profile/og-image.png"><link rel=canonical href=https://charlie.engineer/posts/agentctl/><link rel=alternate hreflang=en href=https://charlie.engineer/posts/agentctl/><meta property="article:published_time" content="2026-02-26T00:00:00Z"><meta property="article:modified_time" content="2026-02-26T00:00:00Z"><meta property="article:author" content="Charlie Hulcher"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"agentctl: Headless Orchestration for Coding Agents","description":"Engineering Leader and AI Researcher focused on building tech startup teams and exploring advanced AI applications.","author":{"@type":"Person","name":"Charlie Hulcher","url":"https:\/\/charlie.engineer\/"},"datePublished":"2026-02-26T00:00:00Z","dateModified":"2026-02-26T00:00:00Z","url":"https:\/\/charlie.engineer\/posts\/agentctl\/","publisher":{"@type":"Person","name":"Charlie Hulcher"}}</script><meta name=robots content="index, follow"><link rel=icon href=/favicon.ico type=image/x-icon><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><meta name=msapplication-TileColor content="#000000"><meta name=theme-color content="#000000"><link rel=stylesheet href=/css/main.min.f471502f1acb1e3276c936ac6697f5eea90bfbf0ee24125f1e79596876dd2582.css integrity="sha256-9HFQLxrLHjJ2yTasZpf17qkL+/DuJBJfHnlZaHbdJYI="></head><body class=bg-black><div class="min-h-screen bg-black text-white font-mono"><div class="max-w-3xl mx-auto px-4 py-12"><nav class=mb-8><a href=/ class="inline-flex items-center text-zinc-400 hover:text-white transition-colors"><svg class="w-4 h-4 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
Back to Home
</a><a href=/archive/ class="inline-flex items-center text-zinc-400 hover:text-white transition-colors ml-4">Archive</a></nav><article class=space-y-8><header class=space-y-4><h1 class="text-3xl md:text-4xl font-bold font-mono">agentctl: Headless Orchestration for Coding Agents</h1><div class="flex flex-col space-y-2"><div class="flex items-center space-x-4 text-zinc-400"><div class="flex items-center"><svg class="w-4 h-4 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>
<time datetime=2026-02-26>02/2026</time></div><div class="flex items-center"><svg class="w-4 h-4 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
<span>6 min read</span></div></div></div></header><div class="prose prose-invert"><p>I built a CLI that wraps coding agents for headless orchestration.</p><p><img src=agent-ctl-architecture.png alt="agentctl architecture"></p><p><img src=agentctl-terminal.png alt="agentctl terminal"></p><h2 id=the-friction-of-going-headless>The friction of going headless</h2><p>I&rsquo;ve been running coding agents headlessly as my primary way of writing software. Not as a side experiment, but as the default. And the friction points became obvious fast.</p><p>You launch a Claude Code session, move on to something else, and forget what it&rsquo;s doing. You launch another session in the same directory without realizing it, and they clobber each other&rsquo;s work. You hear about a new model or a new agent tool, but the switching cost is high enough that you just stick with what works. Why bother?</p><p>Then there&rsquo;s the supervision layer. I have AI agents that supervise my coding agents: launching sessions, checking progress, reacting when work finishes. For that to work, I need clean tooling that serves both humans and the agents doing the supervising.</p><p>So I built agentctl. It&rsquo;s alpha, but a few folks have been daily driving it for weeks now.</p><h2 id=what-it-is>What it is</h2><p>agentctl is a lightweight CLI that wraps whatever coding agent you use and gives you a standard set of commands to manage headless sessions. It&rsquo;s not a replacement for <code>claude</code> or any other agent CLI. It&rsquo;s the supervisory layer that sits on top.</p><p>The core idea: agentctl reads from native sources. It doesn&rsquo;t maintain its own session registry. The Claude Code adapter reads <code>~/.claude/projects/</code> and cross-references running processes. The Pi adapter reads Pi&rsquo;s session files. This means agentctl always reflects ground truth about what&rsquo;s actually running on your machine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>npm install -g @orgloop/agentctl
</span></span></code></pre></div><h2 id=getting-started>Getting started</h2><p>The basics are simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># See everything running on your system</span>
</span></span><span style=display:flex><span>agentctl list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Include completed sessions from the last 7 days</span>
</span></span><span style=display:flex><span>agentctl list -a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Check what an agent is doing</span>
</span></span><span style=display:flex><span>agentctl peek &lt;session-id&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Launch a new session</span>
</span></span><span style=display:flex><span>agentctl launch -p <span style=color:#e6db74>&#34;Read the spec and implement phase 2&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Stop a session</span>
</span></span><span style=display:flex><span>agentctl stop &lt;session-id&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Resume with new instructions</span>
</span></span><span style=display:flex><span>agentctl resume &lt;session-id&gt; <span style=color:#e6db74>&#34;fix the failing tests&#34;</span>
</span></span></code></pre></div><p>Session IDs support prefix matching, so you only need enough characters to be unique.</p><h2 id=directory-locking>Directory locking</h2><p>One of the first problems I hit was accidentally launching two agents in the same repo. agentctl tracks which directories have active sessions and prevents conflicting launches.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Agents automatically lock their working directory on launch.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Manual locks work too, for when a human is working:</span>
</span></span><span style=display:flex><span>agentctl lock ~/code/my-project --by charlie --reason <span style=color:#e6db74>&#34;manual debugging&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># See all active locks</span>
</span></span><span style=display:flex><span>agentctl locks
</span></span></code></pre></div><p>Manual locks let a human claim a directory and hold it as long as they want. No agent will launch there until the lock is cleared.</p><h2 id=lifecycle-hooks>Lifecycle hooks</h2><p>Hooks let you wire agentctl into the rest of your workflow. They&rsquo;re shell commands that fire at specific points in a session&rsquo;s lifecycle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>agentctl launch -p <span style=color:#e6db74>&#34;implement feature X&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --on-create <span style=color:#e6db74>&#34;echo &#39;Session </span>$AGENTCTL_SESSION_ID<span style=color:#e6db74> started&#39;&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --on-complete <span style=color:#e6db74>&#34;npm test&#34;</span>
</span></span></code></pre></div><p>Available hooks:</p><ul><li><code>--on-create</code>: fires after worktree creation but before the agent launches. This is where you bootstrap the environment: <code>mise trust</code>, <code>yarn install</code>, seed a test database, whatever the agent needs before it starts working.</li><li><code>--on-complete</code>: fires when the session finishes. Run tests, send alerts, trigger the next step.</li><li><code>--pre-merge</code>: fires before <code>agentctl merge</code> commits. Lint, test, validate.</li><li><code>--post-merge</code>: fires after merge pushes or opens a PR. Notify, trigger CI.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>agentctl launch -p <span style=color:#e6db74>&#34;implement feature X&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --worktree <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --on-create <span style=color:#e6db74>&#34;cd </span>$AGENTCTL_CWD<span style=color:#e6db74> &amp;&amp; mise trust &amp;&amp; yarn install&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --on-complete <span style=color:#e6db74>&#34;npm test&#34;</span>
</span></span></code></pre></div><p>Hook scripts receive context through environment variables: <code>AGENTCTL_SESSION_ID</code>, <code>AGENTCTL_CWD</code>, <code>AGENTCTL_ADAPTER</code>, <code>AGENTCTL_BRANCH</code>, and <code>AGENTCTL_EXIT_CODE</code>.</p><h2 id=the-sweep-pattern>The sweep pattern</h2><p>This is the feature I&rsquo;m most excited about. You can launch the same task across different agents, models, and configurations, each in its own git worktree, fully independent.</p><p>Want to know if Claude Opus or Sonnet does a better job on your refactor? Or whether Codex handles it differently than Claude Code? One command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>agentctl launch <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --adapter claude-code --model claude-opus-4-6 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --adapter claude-code --model claude-sonnet-4-5 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  --adapter codex <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span>  -p <span style=color:#e6db74>&#34;refactor the auth module&#34;</span>
</span></span></code></pre></div><p>Each gets its own branch and worktree. No conflicts. When they finish, you compare the results and pick the winner. The switching cost drops to nearly zero.</p><p>For more complex sweeps, a YAML matrix file gives you full expressiveness over parameters.</p><h2 id=adapters>Adapters</h2><p>agentctl supports multiple agent runtimes through an adapter model:</p><ul><li><strong>Claude Code</strong> (default): reads from <code>~/.claude/projects/</code>, cross-references running processes.</li><li><strong>Codex CLI</strong>: reads from <code>~/.codex/sessions/</code>, supports <code>codex exec</code> for headless mode.</li><li><strong>OpenCode</strong>: reads from <code>~/.local/share/opencode/storage/</code>, supports <code>opencode run</code>.</li><li><strong>Pi</strong>: reads from <code>~/.pi/agent/sessions/</code>, uses Pi&rsquo;s print mode for headless execution.</li><li><strong>OpenClaw</strong>: connects to the OpenClaw gateway via WebSocket RPC (read-only).</li></ul><p>Adding a new adapter means implementing the <code>AgentAdapter</code> interface. The CLI and daemon don&rsquo;t change.</p><h2 id=integration-with-orgloop>Integration with OrgLoop</h2><p>agentctl fits into a larger picture. In my setup, it&rsquo;s one layer of three:</p><table><thead><tr><th>Layer</th><th>Role</th></tr></thead><tbody><tr><td><strong>agentctl</strong></td><td>Read/control interface. Discovers sessions, emits lifecycle events.</td></tr><tr><td><strong>OrgLoop</strong></td><td>Routes lifecycle events to mechanical reactions.</td></tr><tr><td><strong>OpenClaw</strong></td><td>Reasoning layer. Makes judgment calls.</td></tr></tbody></table><p>agentctl streams lifecycle events as NDJSON:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>agentctl events --json
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;session.stopped&#34;</span>,<span style=color:#f92672>&#34;adapter&#34;</span>:<span style=color:#e6db74>&#34;claude-code&#34;</span>,<span style=color:#f92672>&#34;sessionId&#34;</span>:<span style=color:#e6db74>&#34;abc123&#34;</span>,<span style=color:#f92672>&#34;timestamp&#34;</span>:<span style=color:#e6db74>&#34;2025-06-15T11:00:00.000Z&#34;</span>,<span style=color:#f92672>&#34;session&#34;</span>:{<span style=color:#960050;background-color:#1e0010>...</span>}}
</span></span></code></pre></div><p>OrgLoop consumes these events and routes them to reactions. A session completes, OrgLoop checks the result, and an OpenClaw agent decides what to do next: re-launch with different instructions, open a PR, or flag it for human review.</p><p>This event-driven pattern means agentctl stays simple. It doesn&rsquo;t need to know what should happen when a session finishes. It just says what happened, and the layers above decide.</p><h2 id=fuse-timers>Fuse timers</h2><p>When running agents in worktree-per-branch workflows with Kind clusters, forgotten clusters accumulate. Fuse timers handle this automatically: when a session exits, agentctl starts a countdown. If no new session starts in that directory before the timer expires, the associated cluster gets deleted.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># See active fuses</span>
</span></span><span style=display:flex><span>agentctl fuses
</span></span></code></pre></div><p>Small feature, but it&rsquo;s saved me from more than a few resource leaks.</p><h2 id=the-daemon>The daemon</h2><p>agentctl runs a lightweight daemon that provides session tracking, directory locks, fuse timers, and Prometheus metrics. It auto-starts on your first command and can be installed as a macOS LaunchAgent for persistence:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>agentctl daemon install    <span style=color:#75715e># Auto-start on login</span>
</span></span><span style=display:flex><span>agentctl daemon status     <span style=color:#75715e># Check health</span>
</span></span></code></pre></div><p>Prometheus metrics are exposed at <code>localhost:9200/metrics</code> for monitoring active sessions, lock counts, session durations, and fuse activity.</p><h2 id=where-this-is-heading>Where this is heading</h2><p>I believe headless coding agents will become the default path sooner than most people expect. Not that interactive sessions go away, but that the majority of code written will come from headless agents. agentctl is the supervision layer I needed to make that work, and it&rsquo;s a piece of what I&rsquo;ve been building toward: organizations as code for autonomous intelligence scaling.</p><p>Open source, MIT licensed. Try it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>npm install -g @orgloop/agentctl
</span></span></code></pre></div><p>GitHub: <a href=https://github.com/orgloop/agentctl>github.com/orgloop/agentctl</a></p></div></article><footer class="mt-12 pt-8 border-t border-zinc-800"><div class="flex justify-between items-center"><div class="flex items-center space-x-4"><img src=/images/profile/avatar.png alt="Charlie Hulcher" width=50 height=50 class="rounded-full grayscale"><div><h3 class="font-bold font-mono">Charlie Hulcher</h3><p class="text-zinc-400 text-sm">Engineering Leader & AI Researcher</p></div></div></div></footer></div></div><img src="https://charlie-engineer.goatcounter.com/count?p=%2fposts%2fagentctl%2f&t=agentctl%3a%20Headless%20Orchestration%20for%20Coding%20Agents" alt style=position:absolute;left:-9999px aria-hidden=true></body></html>